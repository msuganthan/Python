
Data types:
===========

int 
float
complex
bool
str
bytes
bytearray
range
list
tuple
set
fronzenset
dict
None

Internally everything is an object in Python

1. int:
========
The number without integral value.
a=10
id(a)
type(a)

Ways to represent intergral values

  1. Decimal form ==> a=7878
  2. Binary form  ==> 0B1111, 0b1111
  3. Octal form   ==> 0o8789, 0O7989
  4. Hexa Decimal ==> 0x3233, 0x3298
  
Integer: There is no long type in python3
========

Convert any base to another base

bin()
oct()
hex()

bin(0o777)
bin(0X1234)
oct(789)
oct(0XFACE)
oct(0B1111)
hex(0B1111)

Float:(There is no double value)
======
f=123.456(valid)
f=0X123.456(invalid)
f=0o123.345(invalid)
f=1.2e3(valid)

String
=======
str
index
slice
*
len(s)

char typs is not available.

Type-casting
=============
int() ==> can't convert complex to int
  int(10.123) ==> 10
  int(True)   ==> 1
  int(False)  ==> 0
  int("10")   ==> can
  int("10.5") ==> can't
  
float() ==> can't convert complex to float
  float(10)    ==> 10.0
  float(10+5j) ==> Type error
  float(True)  ==> 1.0
  float("ten") ==> this conversion is not possible
  float("0B1212") ==> Type error
  float("10")     ==> 10.0
  
complex():
-----------
complex(10) ==> 10+0j
complex(10.5) ==> 10.5+0j
complex(True) ==> 1 + 0j
complex(False) ==> 0 + 0j
complex("10")  ==> 10 = 0j
complex("ten") ==> arg is a malformed string

complex(10, 20) ==> 10 + 20j
complex(True, False) ==> 1 + 0j
complex(10, 20.5)    ==> 10 + 20.5j
complex("10", "12")  ==> can't take second arg if the first arg is string


bool()
======
bool(0) ==> False
bool(10) ==> True
bool(-10) ==> True

bool(0.0) ==> False
bool(0.1) ==> True
bool(0.01) ==> True

bool(0+0j) ==> False
bool(10+20j) ==> True

bool('')  ==> False
bool('sugan') ==> True
bool(' ') ==> True

str()
=====
pass anything you will get the string
